Created by PLY version 3.6 (http://www.dabeaz.com/ply)

Unused terminals:

    LNOT
    LBRACKET
    LE
    SEMI
    WHERE
    NE
    LT
    STRING
    PERIOD
    GT
    XOR
    EQUALS
    RBRACE
    GE
    ELLIPSIS
    SERIESEQUALS
    EQ
    ID
    IF
    AND
    ON
    LBRACE
    NOT
    RBRACKET
    COMMA
    OR

Grammar

Rule 0     S' -> expr
Rule 1     expr -> INTEGER
Rule 2     expr -> FLOAT
Rule 3     expr -> LOCALID
Rule 4     expr -> expr PLUS expr
Rule 5     expr -> expr MINUS expr
Rule 6     expr -> expr TIMES expr
Rule 7     expr -> expr DIVIDE expr
Rule 8     expr -> LPAREN expr RPAREN

Terminals, with rules where they appear

AND                  : 
COMMA                : 
DIVIDE               : 7
ELLIPSIS             : 
EQ                   : 
EQUALS               : 
FLOAT                : 2
GE                   : 
GT                   : 
ID                   : 
IF                   : 
INTEGER              : 1
LBRACE               : 
LBRACKET             : 
LE                   : 
LNOT                 : 
LOCALID              : 3
LPAREN               : 8
LT                   : 
MINUS                : 5
NE                   : 
NOT                  : 
ON                   : 
OR                   : 
PERIOD               : 
PLUS                 : 4
RBRACE               : 
RBRACKET             : 
RPAREN               : 8
SEMI                 : 
SERIESEQUALS         : 
STRING               : 
TIMES                : 6
WHERE                : 
XOR                  : 
error                : 

Nonterminals, with rules where they appear

expr                 : 4 4 5 5 6 6 7 7 8 0

Parsing method: LALR

state 0

    (0) S' -> . expr
    (1) expr -> . INTEGER
    (2) expr -> . FLOAT
    (3) expr -> . LOCALID
    (4) expr -> . expr PLUS expr
    (5) expr -> . expr MINUS expr
    (6) expr -> . expr TIMES expr
    (7) expr -> . expr DIVIDE expr
    (8) expr -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 5
    FLOAT           shift and go to state 3
    LOCALID         shift and go to state 1
    LPAREN          shift and go to state 4

    expr                           shift and go to state 2

state 1

    (3) expr -> LOCALID .

    PLUS            reduce using rule 3 (expr -> LOCALID .)
    MINUS           reduce using rule 3 (expr -> LOCALID .)
    TIMES           reduce using rule 3 (expr -> LOCALID .)
    DIVIDE          reduce using rule 3 (expr -> LOCALID .)
    $end            reduce using rule 3 (expr -> LOCALID .)
    RPAREN          reduce using rule 3 (expr -> LOCALID .)


state 2

    (0) S' -> expr .
    (4) expr -> expr . PLUS expr
    (5) expr -> expr . MINUS expr
    (6) expr -> expr . TIMES expr
    (7) expr -> expr . DIVIDE expr

    PLUS            shift and go to state 7
    MINUS           shift and go to state 8
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 6


state 3

    (2) expr -> FLOAT .

    PLUS            reduce using rule 2 (expr -> FLOAT .)
    MINUS           reduce using rule 2 (expr -> FLOAT .)
    TIMES           reduce using rule 2 (expr -> FLOAT .)
    DIVIDE          reduce using rule 2 (expr -> FLOAT .)
    $end            reduce using rule 2 (expr -> FLOAT .)
    RPAREN          reduce using rule 2 (expr -> FLOAT .)


state 4

    (8) expr -> LPAREN . expr RPAREN
    (1) expr -> . INTEGER
    (2) expr -> . FLOAT
    (3) expr -> . LOCALID
    (4) expr -> . expr PLUS expr
    (5) expr -> . expr MINUS expr
    (6) expr -> . expr TIMES expr
    (7) expr -> . expr DIVIDE expr
    (8) expr -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 5
    FLOAT           shift and go to state 3
    LOCALID         shift and go to state 1
    LPAREN          shift and go to state 4

    expr                           shift and go to state 10

state 5

    (1) expr -> INTEGER .

    PLUS            reduce using rule 1 (expr -> INTEGER .)
    MINUS           reduce using rule 1 (expr -> INTEGER .)
    TIMES           reduce using rule 1 (expr -> INTEGER .)
    DIVIDE          reduce using rule 1 (expr -> INTEGER .)
    $end            reduce using rule 1 (expr -> INTEGER .)
    RPAREN          reduce using rule 1 (expr -> INTEGER .)


state 6

    (7) expr -> expr DIVIDE . expr
    (1) expr -> . INTEGER
    (2) expr -> . FLOAT
    (3) expr -> . LOCALID
    (4) expr -> . expr PLUS expr
    (5) expr -> . expr MINUS expr
    (6) expr -> . expr TIMES expr
    (7) expr -> . expr DIVIDE expr
    (8) expr -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 5
    FLOAT           shift and go to state 3
    LOCALID         shift and go to state 1
    LPAREN          shift and go to state 4

    expr                           shift and go to state 11

state 7

    (4) expr -> expr PLUS . expr
    (1) expr -> . INTEGER
    (2) expr -> . FLOAT
    (3) expr -> . LOCALID
    (4) expr -> . expr PLUS expr
    (5) expr -> . expr MINUS expr
    (6) expr -> . expr TIMES expr
    (7) expr -> . expr DIVIDE expr
    (8) expr -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 5
    FLOAT           shift and go to state 3
    LOCALID         shift and go to state 1
    LPAREN          shift and go to state 4

    expr                           shift and go to state 12

state 8

    (5) expr -> expr MINUS . expr
    (1) expr -> . INTEGER
    (2) expr -> . FLOAT
    (3) expr -> . LOCALID
    (4) expr -> . expr PLUS expr
    (5) expr -> . expr MINUS expr
    (6) expr -> . expr TIMES expr
    (7) expr -> . expr DIVIDE expr
    (8) expr -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 5
    FLOAT           shift and go to state 3
    LOCALID         shift and go to state 1
    LPAREN          shift and go to state 4

    expr                           shift and go to state 13

state 9

    (6) expr -> expr TIMES . expr
    (1) expr -> . INTEGER
    (2) expr -> . FLOAT
    (3) expr -> . LOCALID
    (4) expr -> . expr PLUS expr
    (5) expr -> . expr MINUS expr
    (6) expr -> . expr TIMES expr
    (7) expr -> . expr DIVIDE expr
    (8) expr -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 5
    FLOAT           shift and go to state 3
    LOCALID         shift and go to state 1
    LPAREN          shift and go to state 4

    expr                           shift and go to state 14

state 10

    (8) expr -> LPAREN expr . RPAREN
    (4) expr -> expr . PLUS expr
    (5) expr -> expr . MINUS expr
    (6) expr -> expr . TIMES expr
    (7) expr -> expr . DIVIDE expr

    RPAREN          shift and go to state 15
    PLUS            shift and go to state 7
    MINUS           shift and go to state 8
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 6


state 11

    (7) expr -> expr DIVIDE expr .
    (4) expr -> expr . PLUS expr
    (5) expr -> expr . MINUS expr
    (6) expr -> expr . TIMES expr
    (7) expr -> expr . DIVIDE expr

    PLUS            reduce using rule 7 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 7 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 7 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 7 (expr -> expr DIVIDE expr .)
    $end            reduce using rule 7 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 7 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 7 ]
  ! MINUS           [ shift and go to state 8 ]
  ! TIMES           [ shift and go to state 9 ]
  ! DIVIDE          [ shift and go to state 6 ]


state 12

    (4) expr -> expr PLUS expr .
    (4) expr -> expr . PLUS expr
    (5) expr -> expr . MINUS expr
    (6) expr -> expr . TIMES expr
    (7) expr -> expr . DIVIDE expr

    PLUS            reduce using rule 4 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 4 (expr -> expr PLUS expr .)
    $end            reduce using rule 4 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 4 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 6

  ! TIMES           [ reduce using rule 4 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 4 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 7 ]
  ! MINUS           [ shift and go to state 8 ]


state 13

    (5) expr -> expr MINUS expr .
    (4) expr -> expr . PLUS expr
    (5) expr -> expr . MINUS expr
    (6) expr -> expr . TIMES expr
    (7) expr -> expr . DIVIDE expr

    PLUS            reduce using rule 5 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 5 (expr -> expr MINUS expr .)
    $end            reduce using rule 5 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 5 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 6

  ! TIMES           [ reduce using rule 5 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 5 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 7 ]
  ! MINUS           [ shift and go to state 8 ]


state 14

    (6) expr -> expr TIMES expr .
    (4) expr -> expr . PLUS expr
    (5) expr -> expr . MINUS expr
    (6) expr -> expr . TIMES expr
    (7) expr -> expr . DIVIDE expr

    PLUS            reduce using rule 6 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 6 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 6 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 6 (expr -> expr TIMES expr .)
    $end            reduce using rule 6 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 6 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 7 ]
  ! MINUS           [ shift and go to state 8 ]
  ! TIMES           [ shift and go to state 9 ]
  ! DIVIDE          [ shift and go to state 6 ]


state 15

    (8) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 8 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 8 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 8 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 8 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 8 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 8 (expr -> LPAREN expr RPAREN .)

